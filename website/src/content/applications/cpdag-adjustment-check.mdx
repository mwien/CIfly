---
title: Verifying adjustment sets
summary: Test whether a set of variables can be used for adjustment for a given CPDAG and sets of treatment and outcome variables. 
code: [cpdag_adjustment_check.py, cpdagAdjustmentCheck.R]
ruletables: [not_amenable_cpdag, possible_ancestors_cpdag, possible_descendants_cpdag, backdoor_connected_cpdag]
graph: CPDAG
references: [perkovicComplete]
number: 1
---

import CodeHelper from "../../components/CodeHelper.astro"
import CodeSwitcher from "../../components/CodeSwitcher.astro"
import ExampleCode from "../../components/ExampleCode.astro"
import Ruletable from "../../components/Ruletable.astro"
import Reference from "../../components/Reference.astro"

In this article, we show how to implement a CPDAG adjustment checker using CIfly. We directly rely on the graphical criterion derived by <Reference id="perkovicComplete" format="author(year)"/>. Adjustment is a fundamental technique for identifying causal effects. Utilizing this technique in combination with CPDAGs (these causal graphs that can be learned from data), enables the possibility of combining causal discovery and causal effect estimation. As we will be purely focused on implementing an algorithm checking this criterion and refer the reader to the paper for additional background on CPDAGs and adjustment. 

**Theorem** [<Reference id="perkovicComplete" format="author(year)"/>]    
Consider disjoint node sets $X$, $Y$ and $Z$ in a CPDAG $G$. Then, $Z$ is a valid adjustment set relative to $(X, Y)$ in $G$ if, and only if,
1. all proper possibly directed paths from $X$ to $Y$ begin with a directed edge,
2. $\text{forb}_G(X, Y) \cap Z = \emptyset$ and
3. all proper definite-status non-causal paths from $X$ to $Y$ are blocked by $Z$ in $G$.

The criterion is formulated for CPDAGs, which are graphs with both directed and undirected edges. They do not contain directed cycles and satisfy additional properties, which we, however, do not discuss in this article. The graphical terminology in the criterion is introduced below. 

The first condition of the Theorem is called *amenability*, the second *forbidden set* and the third *blocking*. Our implementation proceeds by checking these conditions one-by-one.

#### Amenability condition
Let us first revisit the notion of a proper possibly directed path. A *proper* path between $X$ and $Y$ is one which contains exactly one node from $X$ and one node from $Y$ (the endpoints of the path). A path is *possibly directed* from $X$ to $Y$ if every edge on it is either undirected or points towards the node in $Y$. For example, $x \rightarrow u - v \rightarrow y$ is, for $X = \{x\}$ and $Y = \{y\}$, a possibly directed path from $X$ to $Y$. The condition refers to those proper possibly directed paths that start with an undirected edge out of $X$, for example $x - u - v \rightarrow y$ would be such a path. 

In our [documentation](/docs/python-wrapper/), we already used the rule table below for finding all non-amenable nodes as a running example. It finds all nodes $v$ for which there exists a proper possibly directed path starting with an undirected edge from a node $x \in X$ to $v$. Effectively, these are the nodes that cannot be in set $Y$. 

<Ruletable id="not_amenable_cpdag" withHeader={true}/>

To check amenability, one can hence use this ruletable for set $X$ and check whether the intersection of returned nodes with $Y$ is empty. 

#### Forbidden set condition
The forbidden set $\text{forb}_G(X, Y)$ contains all nodes that are *possible descendants* of a node $w$ that lies on a proper possibly directed path from $X$ to $Y$. A possible descendant of $w$ is a node $v$ such that there exists a possibly directed path from $w$ to $v$. 
We compute the forbidden set in multiple steps. First, we find all $w$ on a proper possibly directed path from $X$ to $Y$. Afterwards, we find the possible descendants of these $w$. The first step can be done by finding all nodes on a proper possibly directed path from $X$ that does not contain a node in $Y$ and, vice versa, all nodes from which there exists a proper possibly directed path to $Y$ not containing a node in $X$. By definition, the intersection of these two node sets are precisely the nodes which lie on a proper possibly directed path from $X$ to $Y$. 

Hence, we need a table for finding nodes on proper possibly directed paths from $X$ with the option to stop before nodes of a passed set $W$ are reached. Clearly, this table can also be used to find possible descendants. 

<Ruletable id="possible_descendants_cpdag" withHeader={true}/>

We also need to find the nodes from which there exists a proper possibly directed path to $Y$. For this, we can simply start the reachability algorithm at $Y$ and traverse these paths the opposite way. 

<Ruletable id="possible_ancestors_cpdag" withHeader={true}/>

Using these tables, the forbidden set can be computed as follows.

<CodeSwitcher>
<CodeHelper slot="python-code" code={
`anc = cf.reach(g, {"X": Y, "W": X}, "./possible_ancestors_cpdag.txt")
des = cf.reach(g, {"X": X, "W": []}, "./possible_descendants_cpdag.txt")
cn = set(anc).intersection(des)
forb = cf.reach(g, {"X": cn}, "./possible_descendants_cpdag.txt")`
} lang="py" title="" />
<CodeHelper slot="r-code" code={
`anc <- reach(cpdag, list("X" = Y, "W" = X), "./possible_ancestors_cpdag.txt")
des <- reach(cpdag, list("X" = X, "W" = c()), "./possible_descendants_cpdag.txt")
cn <- intersect(anc, des)
forb <- reach(cpdag, list("X" = cn), "./possible_descendants_cpdag.txt")`
} lang="r" title="" />
</CodeSwitcher>

#### Blocking condition
The blocking condition concerns itself with proper definite-status non-causal paths. Again, let us briefly introduce this terminology. A path from $X$ to $Y$ is called *non-causal* if it is not possibly directed from $X$ to $Y$. Further, a path is *definite-status* if every non-endpoint node on it is either a collider or a definite non-collider on the path. A *collider* is a node $w$ such that it is connected to its neighbors on the path as $u \rightarrow w \leftarrow v$. A *definite non-collider* is a node $w$ where the edge to its neighbor $u$ or to its neighbor $v$ points towards $u$, respectively $v$, or where both edges are undirected. 

To check the condition, it should be verified that proper definite-status non-causal paths are blocked given $Z$. For this, it has hold that there exists a collider $w$ on the path such $w \not\in Z$ or a definite-status non-colllider $w$ such that $w \in Z$. We again verify this by finding all reachable nodes and checking that $Y$ contains no such nodes. To do this, we use the following table. 

<Ruletable id="backdoor_connected_cpdag" withHeader={true}/>

This table tracks definite-status paths open given $Z$ exactly as discussed above. To ensure that they are non-causal, any transition from $X$ to a node in $C$ (a set containing all nodes on a possible directed path from $X$ to $Y$) is excluded in the table. For this, it is explicitly used that the amenability condition ensures that only directed edges from $X$ to $C$ may exist (else the exclusion of transitions from $X$ to $C$ would need to be added to the second and fourth rule as well). 

#### Full implementation
The implementation uses the four tables introduced above to check the conditions one-by-one. We note that it would be possible to return early if the first or second condition is violated. This is omitted here for sake of a clearer presentation. 

We rely on a function in ```utils``` that returns the path to the rule-table folder. In Python, this function returns a ```Path``` object from the ```pathlib``` library. In R, it returns a string holding this path, which is created using the ```here``` library. 

<CodeSwitcher>
	<ExampleCode slot="python-code" id="cpdag_adjustment_check.py"/>
	<ExampleCode slot="r-code" id="cpdagAdjustmentCheck.R"/>
</CodeSwitcher>
